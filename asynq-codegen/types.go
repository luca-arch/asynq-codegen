package asynqcodegen

import (
	_ "embed"
	"errors"
	"fmt"
	"go/ast"
	"log/slog"
	"strconv"
	"strings"
	"time"
)

// Default values for generated asynq.Option.
const (
	DefaultRetry       = 5
	DefaultTaskTimeout = time.Minute
)

// errNoDirective is returned to [Inspect] when a type/node needs to be skipped.
var errNoDirective = errors.New("ok")

//go:embed asynq_generate.tpl
var xrvTpl string

// InspectResult is returned by [Inspect] after successful parsing.
type InspectResult struct {
	Comments    []AsynqComment
	PackageName string
}

// AsynqComment is generated by [Inspect].
//
// It contains all the asynq directives specified in a struct's comment.
type AsynqComment struct {
	Attributes  map[string]string
	PackageName string
	StructName  string
}

// TypeName returns a string that uniquely identifies a task type. If the name is not specified, a default snake-case
// string will be returned instead.
//
// E.g. assume a type MyMessage struct:
//
//   - asynq:task -> returns pkg:my_message
//   - asynq:task notification -> returns pkg:notification
func (a *AsynqComment) TypeName() string {
	out := a.Attributes["task"]
	if out == "" {
		out = snakeCase(a.StructName)

		slog.Info("AsynqComment: no task name specified, defaulting to "+out, "struct", a.StructName)
	}

	return a.PackageName + ":" + out
}

// Retry returns the maximum number of retries (passed as asynq.Option).
// It defaults to [DefaultRetry] if the value is not specified or if it's not a valid number.
//
// E.g. assume a type MyMessage struct:
//
//   - asynq:retry 3 -> returns 3
//   - asynq:retry BAD -> returns [DefaultRetry].
func (a *AsynqComment) Retry() int {
	in := a.Attributes["retry"]
	if in == "" {
		return DefaultRetry
	}

	out, err := strconv.Atoi(in)
	if err == nil {
		return out
	}

	slog.Info("AsynqComment: retry value is not an integer, defaulting to "+strconv.Itoa(DefaultRetry),
		slog.String("value", in),
		slog.String("struct", a.StructName),
	)

	return DefaultRetry
}

// Timeout returns the maximum allowed time to complete the task (passed as asynq.Option).
// It defaults to [DefaultTaskTimeout] if the value is not specified or if it's not a valid duration.
//
// E.g. assume a type MyMessage struct:
//
//   - asynq:timeout 10m -> returns 10 * [time.Minute]
//   - asynq:timeout BAD -> returns [DefaultTaskTimeout].
func (a *AsynqComment) Timeout() time.Duration {
	in := a.Attributes["timeout"]
	if in == "" {
		return DefaultTaskTimeout
	}

	out, err := time.ParseDuration(in)
	if err == nil {
		return out
	}

	slog.Info("AsynqComment: invalid timeout, defaulting to "+DefaultTaskTimeout.String(),
		slog.String("value", in),
		slog.String("struct", a.StructName),
		slog.String("error", err.Error()),
	)

	return DefaultTaskTimeout
}

// NewAsynqComment parses a struct's [ast.CommentGroup], reading all comments that start with "asynq:".
//
//nolint:forbidigo // Supersedes err113.
func NewAsynqComment(doc *ast.CommentGroup, pkgName, structName string) (*AsynqComment, error) {
	if doc == nil || len(doc.List) == 0 {
		return nil, errNoDirective
	}

	attrs := make(map[string]string)

	for _, c := range doc.List {
		if !strings.HasPrefix(c.Text, "// asynq:") {
			continue
		}

		var (
			k string
			v string

			//nolint:mnd // Expects two tokens per line
			kv = strings.SplitN(strings.TrimPrefix(c.Text, "// asynq:"), " ", 2)
		)

		switch len(kv) {
		case 0:
			//nolint:err113 // Keep this error contextualised.
			return nil, fmt.Errorf("empty comment directive in %s.%s: %s",
				pkgName, structName, c.Text,
			)
		case 1:
			k = kv[0]
		default:
			k, v = kv[0], strings.TrimSpace(kv[1])
		}

		// TODO: todo001 - reject unknown keys.

		if _, exists := attrs[k]; exists {
			slog.Warn("AsynqComment: duplicate directive " + k + " found in " + structName)
		}

		attrs[k] = v
	}

	return &AsynqComment{
		Attributes:  attrs,
		PackageName: pkgName,
		StructName:  structName,
	}, nil
}
