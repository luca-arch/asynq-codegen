// Code generated by "asynq-codegen"; DO NOT EDIT

package {{ .PackageName }}

import (
    "context"
    "encoding/json"
    "fmt"
    "io"
    "time"

    "github.com/hibiken/asynq"
)

// Auto-generated constants for use with [asynq.NewTask], [asynq.ServeMux.Handle],
// and [asynq.ServeMux.HandleFunc].
const (
{{- range $arg := .Comments }}
    // Type{{ .StructName }} is wired to [asynq.Task.Type], [asynq.ServeMux.Handle] and [asynq.ServeMux.HandleFunc].
    Type{{ .StructName }} = "{{ .TypeName }}"
{{- end -}}
)

{{/* Interfaces of asynq package */}}
type asynqClient interface {
    // EnqueueContext is https://pkg.go.dev/github.com/hibiken/asynq#Client.EnqueueContext.
    EnqueueContext(context.Context, *asynq.Task, ...asynq.Option) (*asynq.TaskInfo, error)
}

type asynqMux interface {
    // HandleFunc is https://pkg.go.dev/github.com/hibiken/asynq#ServeMux.HandleFunc.
    HandleFunc(string, func(context.Context, *asynq.Task) error)
}

{{/* Aliases for consumer functions */}}
{{- range $arg := .Comments }}
// {{ .StructName }}Processor describes a function that processes [{{ .StructName }}].
//
// This type is auto-generated.
type {{ .StructName }}Processor = func (context.Context, *{{ .StructName }}) error
{{ end -}}

// Processors defines methods to process messages by their type.
//
// This type is auto-generated.
type Processors struct {
{{- range $arg := .Comments }}
    {{ .StructName }} {{ .StructName }}Processor
{{- end -}}
}

// Handle register all non-nil handlers with [asynq.ServeMux.HandleFunc].
func (p *Processors) Handle(mux asynqMux) {
    {{- range $arg := .Comments }}
        if p.{{ .StructName }} != nil {
            mux.HandleFunc(Type{{ .StructName }}, New{{ .StructName }}Processor(p.{{ .StructName }}))
        }
    {{ end -}}
}

// HandleAll register all handlers with [asynq.ServeMux.HandleFunc]. It returns an error if any handler is nil.
func (p *Processors) HandleAll(mux asynqMux) error {
    {{- range $arg := .Comments }}
        if p.{{ .StructName }} == nil {
            return fmt.Errorf("nil Processors.{{ .StructName }}")
        }
    {{ end }}

    {{- range $arg := .Comments }}
        mux.HandleFunc(Type{{ .StructName }}, New{{ .StructName }}Processor(p.{{ .StructName }}))
    {{ end }}

    return nil
}

{{/* Tasks factories */}}
{{- range $arg := .Comments }}
// New{{ .StructName }}FromJSON consumes a JSON input and returns a [{{ .StructName }}].
// Any error returned by [json.Unmarshal] will be returned as-is.
//
// This function is auto-generated.
func New{{ .StructName }}FromJSON(r io.Reader) (*{{ .StructName }}, error) {
    var out {{ .StructName }}

    if err :=  json.NewDecoder(r).Decode(&out); err != nil {
        return nil, err
    }

    return &out, nil
}

// New{{ .StructName }}FromJSONBytes reads a JSON bytestream and returns a [{{ .StructName }}].
//
// Any error returned by [json.Unmarshal] will be returned as-is.
//
// This function is auto-generated.
func New{{ .StructName }}FromJSONBytes(b []byte) (*{{ .StructName }}, error) {
    var out {{ .StructName }}

    if err := json.Unmarshal(b, &out); err != nil {
        return nil, err
    }

    return &out, nil
}

// New{{ .StructName }}Task takes a [{{ .StructName }}] pointer and returns a new [asynq.Task] with
// its typename set to [Type{{ .StructName }}].
//
// It returns an error if the pointer is nil, or if it cannot be marshalled.
//
// Task's options:
//
//    - Max retries: {{ .Retry }}
//    - Timeout: {{ .Timeout.String }}
//
// This function is auto-generated.
func New{{ .StructName }}Task(t *{{ .StructName }}) (*asynq.Task, error) {
    if t == nil {
        return nil, fmt.Errorf("nil {{ .StructName }} pointer")
    }

    payload, err := json.Marshal(t)
    if err != nil {
        return nil, fmt.Errorf("marshalling {{ .StructName }}: %w", err)
    }

    return asynq.NewTask(
        Type{{ .StructName }},
        payload,
        asynq.MaxRetry({{ .Retry }}),
        asynq.Timeout({{ .Timeout.Milliseconds }} * time.Millisecond),
    ), nil
}
{{ end -}}

{{/* Consumer factories */}}
{{- range $arg := .Comments }}
    // New{{ .StructName }}Processor wraps a [{{ .StructName }}Processor] function so that it can be passed
    // to [asynq.ServeMux.Handle] and [asynq.ServeMux.HandleFunc].
    //
    // Notes about the returned function:
    //     - it will reject nil tasks and tasks of which the typename does not match [Type{{ .StructName }}].
    //     - it will return an error if a task's payload cannot be unmarshalled.
    //     - it will return any received error as-is, including [asynq.SkipRetry] and [asynq.RevokeTask].
    //
    // This function is auto-generated.
    func New{{ .StructName }}Processor(fn {{ .StructName }}Processor) func(context.Context, *asynq.Task) error {
        return func (ctx context.Context, task *asynq.Task) error {
            if task == nil {
                return fmt.Errorf("{{ .StructName }}Processor invoked with nil task")
            }

            if task.Type() != Type{{ .StructName }} {
                return fmt.Errorf("{{ .StructName }}Processor invoked with task of type %s instead of %s", task.Type(), Type{{ .StructName }})
            }

            p := task.Payload()

            if len(p) == 0 {
                return fmt.Errorf("{{ .StructName }}Processor invoked with void payload")
            }

            var message {{ .StructName }}

            if err := json.Unmarshal(p, &message); err != nil {
                return fmt.Errorf("{{ .StructName }}Processor invoked with corrupt payload: %w", err)
            }

            return fn(ctx, &message)
        }
    }
{{ end -}}

{{/* Functions to enqueue tasks. */}}
{{- range $arg := .Comments }}
    // Enqueue{{ .StructName }}Context pushes a [{{ .StructName }}] task to the queue.
    //
    // Additional [asynq.Option] can be passed to override the options set by [New{{ .StructName }}Task].
    //
    // This function is auto-generated.
    func Enqueue{{ .StructName }}Context(ctx context.Context, client asynqClient, message *{{ .StructName }}, opts ...asynq.Option) (*asynq.Task, *asynq.TaskInfo, error) {
        task, err := New{{ .StructName }}Task(message)
        if err != nil {
            return nil, nil, err
        }

        info, err := client.EnqueueContext(ctx, task, opts...)
        if err != nil {
            return nil, nil, err
        }

        return task, info, nil
    }
{{ end -}}
