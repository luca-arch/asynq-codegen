// Code generated by "asynq-codegen"; DO NOT EDIT

package example01

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"time"

	"github.com/hibiken/asynq"
)

// Auto-generated constants for use with [asynq.NewTask], [asynq.ServeMux.Handle],
// and [asynq.ServeMux.HandleFunc].
const (
	// TypeSendEmail is wired to [asynq.Task.Type], [asynq.ServeMux.Handle] and [asynq.ServeMux.HandleFunc].
	TypeSendEmail = "example01:send_email"
	// TypeSendSMS is wired to [asynq.Task.Type], [asynq.ServeMux.Handle] and [asynq.ServeMux.HandleFunc].
	TypeSendSMS = "example01:send_sms_message"
)

type asynqClient interface {
	// EnqueueContext is https://pkg.go.dev/github.com/hibiken/asynq#Client.EnqueueContext.
	EnqueueContext(context.Context, *asynq.Task, ...asynq.Option) (*asynq.TaskInfo, error)
}

type asynqMux interface {
	// HandleFunc is https://pkg.go.dev/github.com/hibiken/asynq#ServeMux.HandleFunc.
	HandleFunc(string, func(context.Context, *asynq.Task) error)
}

// SendEmailProcessor describes a function that processes [SendEmail].
//
// This type is auto-generated.
type SendEmailProcessor = func(context.Context, *SendEmail) error

// SendSMSProcessor describes a function that processes [SendSMS].
//
// This type is auto-generated.
type SendSMSProcessor = func(context.Context, *SendSMS) error

// Processors defines methods to process messages by their type.
//
// This type is auto-generated.
type Processors struct {
	SendEmail SendEmailProcessor
	SendSMS   SendSMSProcessor
}

// Handle register all non-nil handlers with [asynq.ServeMux.HandleFunc].
func (p *Processors) Handle(mux asynqMux) {
	if p.SendEmail != nil {
		mux.HandleFunc(TypeSendEmail, NewSendEmailProcessor(p.SendEmail))
	}

	if p.SendSMS != nil {
		mux.HandleFunc(TypeSendSMS, NewSendSMSProcessor(p.SendSMS))
	}
}

// HandleAll register all handlers with [asynq.ServeMux.HandleFunc]. It returns an error if any handler is nil.
func (p *Processors) HandleAll(mux asynqMux) error {
	if p.SendEmail == nil {
		return fmt.Errorf("nil Processors.SendEmail")
	}

	if p.SendSMS == nil {
		return fmt.Errorf("nil Processors.SendSMS")
	}

	mux.HandleFunc(TypeSendEmail, NewSendEmailProcessor(p.SendEmail))

	mux.HandleFunc(TypeSendSMS, NewSendSMSProcessor(p.SendSMS))

	return nil
}

// NewSendEmailFromJSON consumes a JSON input and returns a [SendEmail].
// Any error returned by [json.Unmarshal] will be returned as-is.
//
// This function is auto-generated.
func NewSendEmailFromJSON(r io.Reader) (*SendEmail, error) {
	var out SendEmail

	if err := json.NewDecoder(r).Decode(&out); err != nil {
		return nil, err
	}

	return &out, nil
}

// NewSendEmailFromJSONBytes reads a JSON bytestream and returns a [SendEmail].
//
// Any error returned by [json.Unmarshal] will be returned as-is.
//
// This function is auto-generated.
func NewSendEmailFromJSONBytes(b []byte) (*SendEmail, error) {
	var out SendEmail

	if err := json.Unmarshal(b, &out); err != nil {
		return nil, err
	}

	return &out, nil
}

// NewSendEmailTask takes a [SendEmail] pointer and returns a new [asynq.Task] with
// its typename set to [TypeSendEmail].
//
// It returns an error if the pointer is nil, or if it cannot be marshalled.
//
// Task's options:
//
//   - Max retries: 5
//   - Timeout: 1m0s
//
// This function is auto-generated.
func NewSendEmailTask(t *SendEmail) (*asynq.Task, error) {
	if t == nil {
		return nil, fmt.Errorf("nil SendEmail pointer")
	}

	payload, err := json.Marshal(t)
	if err != nil {
		return nil, fmt.Errorf("marshalling SendEmail: %w", err)
	}

	return asynq.NewTask(
		TypeSendEmail,
		payload,
		asynq.MaxRetry(5),
		asynq.Timeout(60000*time.Millisecond),
	), nil
}

// NewSendSMSFromJSON consumes a JSON input and returns a [SendSMS].
// Any error returned by [json.Unmarshal] will be returned as-is.
//
// This function is auto-generated.
func NewSendSMSFromJSON(r io.Reader) (*SendSMS, error) {
	var out SendSMS

	if err := json.NewDecoder(r).Decode(&out); err != nil {
		return nil, err
	}

	return &out, nil
}

// NewSendSMSFromJSONBytes reads a JSON bytestream and returns a [SendSMS].
//
// Any error returned by [json.Unmarshal] will be returned as-is.
//
// This function is auto-generated.
func NewSendSMSFromJSONBytes(b []byte) (*SendSMS, error) {
	var out SendSMS

	if err := json.Unmarshal(b, &out); err != nil {
		return nil, err
	}

	return &out, nil
}

// NewSendSMSTask takes a [SendSMS] pointer and returns a new [asynq.Task] with
// its typename set to [TypeSendSMS].
//
// It returns an error if the pointer is nil, or if it cannot be marshalled.
//
// Task's options:
//
//   - Max retries: 5
//   - Timeout: 1m0s
//
// This function is auto-generated.
func NewSendSMSTask(t *SendSMS) (*asynq.Task, error) {
	if t == nil {
		return nil, fmt.Errorf("nil SendSMS pointer")
	}

	payload, err := json.Marshal(t)
	if err != nil {
		return nil, fmt.Errorf("marshalling SendSMS: %w", err)
	}

	return asynq.NewTask(
		TypeSendSMS,
		payload,
		asynq.MaxRetry(5),
		asynq.Timeout(60000*time.Millisecond),
	), nil
}

// NewSendEmailProcessor wraps a [SendEmailProcessor] function so that it can be passed
// to [asynq.ServeMux.Handle] and [asynq.ServeMux.HandleFunc].
//
// Notes about the returned function:
//   - it will reject nil tasks and tasks of which the typename does not match [TypeSendEmail].
//   - it will return an error if a task's payload cannot be unmarshalled.
//   - it will return any received error as-is, including [asynq.SkipRetry] and [asynq.RevokeTask].
//
// This function is auto-generated.
func NewSendEmailProcessor(fn SendEmailProcessor) func(context.Context, *asynq.Task) error {
	return func(ctx context.Context, task *asynq.Task) error {
		if task == nil {
			return fmt.Errorf("SendEmailProcessor invoked with nil task")
		}

		if task.Type() != TypeSendEmail {
			return fmt.Errorf("SendEmailProcessor invoked with task of type %s instead of %s", task.Type(), TypeSendEmail)
		}

		p := task.Payload()

		if len(p) == 0 {
			return fmt.Errorf("SendEmailProcessor invoked with void payload")
		}

		var message SendEmail

		if err := json.Unmarshal(p, &message); err != nil {
			return fmt.Errorf("SendEmailProcessor invoked with corrupt payload: %w", err)
		}

		return fn(ctx, &message)
	}
}

// NewSendSMSProcessor wraps a [SendSMSProcessor] function so that it can be passed
// to [asynq.ServeMux.Handle] and [asynq.ServeMux.HandleFunc].
//
// Notes about the returned function:
//   - it will reject nil tasks and tasks of which the typename does not match [TypeSendSMS].
//   - it will return an error if a task's payload cannot be unmarshalled.
//   - it will return any received error as-is, including [asynq.SkipRetry] and [asynq.RevokeTask].
//
// This function is auto-generated.
func NewSendSMSProcessor(fn SendSMSProcessor) func(context.Context, *asynq.Task) error {
	return func(ctx context.Context, task *asynq.Task) error {
		if task == nil {
			return fmt.Errorf("SendSMSProcessor invoked with nil task")
		}

		if task.Type() != TypeSendSMS {
			return fmt.Errorf("SendSMSProcessor invoked with task of type %s instead of %s", task.Type(), TypeSendSMS)
		}

		p := task.Payload()

		if len(p) == 0 {
			return fmt.Errorf("SendSMSProcessor invoked with void payload")
		}

		var message SendSMS

		if err := json.Unmarshal(p, &message); err != nil {
			return fmt.Errorf("SendSMSProcessor invoked with corrupt payload: %w", err)
		}

		return fn(ctx, &message)
	}
}

// EnqueueSendEmailContext pushes a [SendEmail] task to the queue.
//
// Additional [asynq.Option] can be passed to override the options set by [NewSendEmailTask].
//
// This function is auto-generated.
func EnqueueSendEmailContext(ctx context.Context, client asynqClient, message *SendEmail, opts ...asynq.Option) (*asynq.Task, *asynq.TaskInfo, error) {
	task, err := NewSendEmailTask(message)
	if err != nil {
		return nil, nil, err
	}

	info, err := client.EnqueueContext(ctx, task, opts...)
	if err != nil {
		return nil, nil, err
	}

	return task, info, nil
}

// EnqueueSendSMSContext pushes a [SendSMS] task to the queue.
//
// Additional [asynq.Option] can be passed to override the options set by [NewSendSMSTask].
//
// This function is auto-generated.
func EnqueueSendSMSContext(ctx context.Context, client asynqClient, message *SendSMS, opts ...asynq.Option) (*asynq.Task, *asynq.TaskInfo, error) {
	task, err := NewSendSMSTask(message)
	if err != nil {
		return nil, nil, err
	}

	info, err := client.EnqueueContext(ctx, task, opts...)
	if err != nil {
		return nil, nil, err
	}

	return task, info, nil
}
